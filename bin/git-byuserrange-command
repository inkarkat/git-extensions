#!/bin/bash
set -o noglob -o pipefail

readonly scriptDir="$([ "${BASH_SOURCE[0]}" ] && dirname -- "${BASH_SOURCE[0]}" || exit 3)"
[ -d "$scriptDir" ] || { echo >&2 'ERROR: Cannot determine script directory!'; exit 3; }
readonly projectDir="${scriptDir}/.."
readonly libDir="${projectDir}/lib"
source "${libDir}/logArgParser.sh" || exit 3

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-r|--revision REVISION] [--author=<pattern>|--committer=<pattern> ...] [--no-range|--with-range RANGE] [--one-more|--one-more-output|--one-more-command GIT-COMMAND2|^[1|2] [--one-more-with-padding] [--one-more-only-to-terminal] [--with-log-args|--with-log-args-except-last|--pass-file-args] ... [-?|-h|--help]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... GIT-COMMAND [... --author=<pattern>|--committer=<pattern> [-r|--revision REVISION] ...]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... --keep-position GIT-COMMAND [... RANGE ... --author=<pattern>|--committer=<pattern> [-r|--revision REVISION] ...]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... [-2 GIT-COMMAND ARG1|-3 GIT-COMMAND ARG1 ARG2|...] [... --author=<pattern>|--committer=<pattern> [-r|--revision REVISION] ...]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... [+1 ARG1|+2 ARG1 ARG2|+3 ARG1 ARG2 ARG3|...] GIT-COMMAND [... --author=<pattern>|--committer=<pattern> [-r|--revision REVISION] ...]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Print / execute GIT-COMMAND with a revision range starting from the passed
REVISION / the most recent revision from the passed author / committer(s) and
including all consecutive commits done by the passed author / committer(s) (or
the author (+ committer if different) from the start revision)
- appended
- replacing RANGE argument(s) anywhere
- replacing RANGE in the following GIT-COMMAND and -(N-1) arguments
- replacing RANGE in the following +(N) arguments and appending those
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --no-range	    Only use the earliest consecutive commit from the passed
		    author.
    --with-range ...
		    Use ... instead of .. as the range specifier.
    --last-only	    Only use the latest commit from the passed author.
    --one-more	    Include the commit preceding the author's commit.
    --with-log-args All GIT-COMMAND log arguments should also be used when
		    determining the revision range.
    --with-log-args-except-last
		    All GIT-COMMAND log arguments expect the very last should
		    also be used when determining the revision range.
HELPTEXT
}

revision=
typeset userFilterArgs=()
withLogArgs=
typeset -a revRangeArgs=()
isWithRange=t
typeset -a logArgs=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;

	# Need to parse off --author|--committer from anywhere first; these here select
	# the user and do not filter commits by author.
	# Same for --revision to determine the start revision.
	--revision|-r)	shift; revision="$1"; shift;;
	--author|--committer)
			userFilterArgs+=("$1" "$2"); shift; shift;;
	--author=*|--committer=*)
			userFilterArgs+=("$1"); shift;;

	--with-log-args)
			shift; withLogArgs=all;;
	--with-log-args-except-last)
			shift; withLogArgs=except-last;;
	--no-range)	revRangeArgs+=("$1"); shift; isWithRange=;;
	--)		break;;
	*)		if { [ "$withLogArgs" = all ] || [ "$withLogArgs" = except-last -a $# -gt 1 ]; } \
			    && { countLogArgs '' "$1"; argCount=$?; [ $argCount -gt 0 ]; }
			then
			    while ((argCount-- > 0))
			    do
				logArgs+=("$1")
				revRangeArgs+=("$1")
				shift
			    done
			else
			    revRangeArgs+=("$1")
			    shift
			fi
			;;
    esac
done
if [ ${#userFilterArgs[@]} -eq 0 ]; then
    author="$(git log --max-count 1 --pretty=format:'%aN <%aE>' "${revision:-HEAD}")" || exit $?
    committer="$(git log --max-count 1 --pretty=format:'%cN <%cE>' "${revision:-HEAD}")" || exit $?
    userFilterArgs+=(--author "$author")
    [ "$author" = "$committer" ] || userFilterArgs+=(--committer "$committer")
fi

if [ -z "$revision" ]; then
    revision="$(git log --max-count 1 --pretty=tformat:%H "${userFilterArgs[@]}" "${logArgs[@]}")"
    if [ -z "$revision" ]; then
	echo >&2 'Could not find a commit from those user(s).'
	exit 1
    fi
fi

startRevision=
< <(diff --unchanged-line-format= --old-line-format='%dn %L' --new-line-format= -- \
    <(git log --first-parent --pretty=tformat:%H "$revision" "${logArgs[@]}") \
    <(git log --first-parent --pretty=tformat:%H "${userFilterArgs[@]}" "$revision" "${logArgs[@]}") # Fortunately, "git log <revision> --follow -- <path>" also works; else, we would have to split logArgs into options and path arguments.
) IFS=' ' read -r firstDifferentCount firstDifferentRevision

if [ -n "$firstDifferentRevision" ]; then
    if [ $firstDifferentCount -eq 1 ]; then
	[ "$author" ] || author="$(git log --max-count 1 --pretty=format:'%aN <%aE>' "$revision" "${logArgs[@]}" 2>/dev/null)"
	printf >&2 'The %s revision already is from another user (%s).\n' "$revision" "$author"
	exit 1
    else
	startRevision="$firstDifferentRevision"
    fi
fi

[ "$isWithRange" ] || revision=''   # Prevent "ERROR: --end-revision cannot be combined with --no-range!"; we don't need the end revision, as --no-range drops that, anyway.

exec git-rev-range --revision "$startRevision" ${revision:+--end-revision "$revision"} "${revRangeArgs[@]}" "$@"
