#!/bin/bash
set -o pipefail

printUsage()
{
    cat <<HELPTEXT
Remove some not so important lines from git pull / fetch, and declutter the output.
HELPTEXT
    printf 'Usage: git pull|fetch [...] | %q %s\n' "$(basename "$1")" '[--fetch] <remote> [-?|-h|--help]'
}
isFetch=
case "$1" in
    --help|-h|-\?)	shift; printUsage "$0"; exit 0;;
    --no-color|--color=*)
			shift;;
    --color)		shift; shift;;
    --fetch)		shift; isFetch=t;;
esac

remote="${1:?}"; shift

massageOutput()
{
    local masterBranch="$(git-mbr)"
    sed --unbuffered \
	-e "/^ \\* branch \+${masterBranch} \+-> FETCH_HEAD\$/d" \
	-e '/^ \(create\|delete\) mode /d' \
	-e '/^Already up to date\.$/d' \
	-e 's#^\( .\+\)\([^ ]\+\) \+-> \+\('"$remote"'/\)\?\2$#\1\2#' \
	-e "/\\(^\\|\\n\\|\\r\\|\\[K\\)Successfully rebased and updated \\(detached HEAD\\|refs\\/heads\\/${masterBranch}\\)\\.\$/d" \
	-e '/Auto packing the repository in background for optimum performance\.$/d' \
	-e '/See "git help gc" for manual housekeeping\.$/d' \

}

declutterOutput()
{
    sed --unbuffered \
	-e '/^From / {
		$d
		N
		/\nNo changes in '"$remote"'/ {
		    N
		    /\nEverything up-to-date$/d
		}

		x
		/./ { x; s/^From [^\n]*\n//; s/^No changes in '"$remote"'[^\n]*\n//; b; }
		g
	    }'
}

joinReferencesLines()
{
    awk -F '[[:space:]]+->[[:space:]]+|[[:space:]]+' \
	-v "remote=${remote//\\/\\\\}" \
'
function typeCompare(t1, t2)
# Returns -1 if t1 +1 == t2, else -99 / 0 / 99.
{
    if (t1 ~ /^[[:digit:]]+$/ && t2 ~ /^[[:digit:]]+$/) {
	t1 = int(t1)
	t2 = int(t2)

	return (t1 == t2 \
		? 0 \
		: (t1 < t2 \
		    ? (t1 + 1 == t2 ? -1 : -99) \
		    : 99 \
		) \
	)
    }

    return (t1 == t2 \
	? 0 \
	: (t1 < t2 ? -99 : 99) \
    )
}
function versionCompare(i1, v1, i2, v2,       n1, a1, n2, a2, i, cmp)
{
    n1 = split(v1, a1, /\./)
    n2 = split(v2, a2, /\./)
    while (n1 < n2) {
	a1[++n1] = -2
    }
    while (n2 < n1) {
	a2[++n2] = -2
    }

    for (i = 1; i <= n1; ++i) {
	cmp = typeCompare(a1[i], a2[i])
	if (cmp != 0) {
	    # All following tuples must match to return a -1 (subsequent value).
	    for (++i; i <= n1; ++i) {
		if (typeCompare(a1[i], a2[i]) != 0) {
		    return cmp * 2  # Nope, not subsequent value.
		}
	    }
	    return cmp
	}
    }
    return 0
}
function lastDigitCompare(v1, v2)
{
    return versionCompare(0, v1, 0, v2)
}
function join(array, start, end, sep,    result, i, range)
{
    if (sep == "")
	sep = " "
    else if (sep == SUBSEP) # magic value
	sep = ""
    result = array[start]
    for (i = start + 1; i <= end; i++)
	if (lastDigitCompare(array[i-1], array[i]) == -1) {
	    range = ".." array[i]
	} else {
	    result = result range sep array[i]
	    range = ""
	}
    return result range
}
function output(text)
{
    if (submodule == "")
	print text
    else
	printf("   %-14s %s\n", submodule, text)
}
function printJoinedReferences(      what)
{
    for (what in n) {
	asort(news[what], news[what], "versionCompare")
	output(sprintf("%-21s", prefix[what] "[" n[what] " " what (n[what] == 1 ? "" : (what ~ /ch$/ ? "e" : "") "s") "]") join(news[what], 1, n[what], ", "))
    }

    delete prefix
    delete news
    delete n
}
BEGIN {
    PROCINFO["sorted_in"] = "@ind_str_asc"
    deletedWhat = "deleted ref"
}
$1 == "Fetching" && $2 == "submodule" {
    printJoinedReferences()
    $1 = ""; $2 = ""; sub(OFS, ""); sub(OFS, ""); submodule = $0
    next
}
$2 == "*" && $3 == "[new" && NF == 5 {
    $4 = substr($4, 1, length($4) - 1)
    newWhat = substr($3, 2) " " $4
    prefix[newWhat] = " " $2 " "
    news[newWhat][++n[newWhat]] = $5
    next
}
$2 ~ /^[x-]$/ && $3 == "[deleted]" && $4 == "(none)" && NF == 5 {
    prefix[deletedWhat] = " " $2 " "
    ref = (substr($5, 1, length(remote) + 1) == remote "/" ? substr($5, length(remote) + 2) : $5)
    news[deletedWhat][++n[deletedWhat]] = ref
    next
}
$1 == "From" {
    printJoinedReferences()
    if (submodule != "") next
}
$1 == "To" { printJoinedReferences() }
$1 == "Updating" { submodule = "" }
{ output($0) }
END { printJoinedReferences() }
'
}

eval "${DEBUG:+debugtee --for git-hushup |} massageOutput | ${isFetch:+joinReferencesLines |} declutterOutput"
