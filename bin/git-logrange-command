#!/bin/bash
set -o noglob

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-r|--revision REVISION] [--no-range|--with-range RANGE] [--one-more|--one-more-output|--one-more-command GIT-COMMAND2|^[1|2] [--one-more-with-padding] [--one-more-only-to-terminal] [--with-log-args|--with-log-args-except-last|--pass-file-args] ... text|/regexp/ [-?|-h|--help]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-r|--revision REVISION] [--no-range|--with-range RANGE] [--one-more|--one-more-output|--one-more-command GIT-COMMAND2|^[1|2] [--one-more-with-padding] [--one-more-only-to-terminal] [--with-log-args|--with-log-args-except-last|--pass-file-args] [--invert-grep] --grep=<pattern> ...'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... GIT-COMMAND [...] [-?|-h|--help]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... --keep-position GIT-COMMAND [... RANGE ...]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... [-2 GIT-COMMAND ARG1|-3 GIT-COMMAND ARG1 ARG2|...] [...]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... [+1 ARG1|+2 ARG1 ARG2|+3 ARG1 ARG2 ARG3|...] GIT-COMMAND [...]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Print / execute GIT-COMMAND with a revision range starting from the passed
REVISION / the most recent revision where ${GIT_LOGRANGE_RANGE_WHAT:?} and including all such following commits where ${GIT_LOGRANGE_RANGE_WHAT:?}
- appended
- replacing RANGE argument(s) anywhere
- replacing RANGE in the following GIT-COMMAND and -(N-1) arguments
- replacing RANGE in the following +(N) arguments and appending those
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --no-range	    Only use the earliest matching commit.
    --with-range ...
		    Use ... instead of .. as the range specifier.
    --last-only	    Only use the latest matching commit.
    --one-more	    Include the commit preceding the earliest matching commit.
    --with-log-args All GIT-COMMAND arguments should also be used when
		    determining the revision range.
    --with-log-args-except-last
		    All GIT-COMMAND arguments expect the very last should also
		    be used when determining the revision range.
HELPTEXT
}

# Need to parse off all command-line arguments except for the GIT-COMMAND first,
# so that parseOffFinalGrepArg doesn't mistakenly hold onto an accidental last
# argument (like REVISION in -r REVISION).
revision=
typeset -a grepArgs=()
typeset -a grepModificationArgs=()
withLogArgs=
typeset -a revRangeArgs=()
isWithRange=t
typeset -a allargs=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--revision|-r)	shift; revision="$1"; shift;;

	--grep)		grepArgs+=("$1" "$2"); shift; shift;;
	--grep=*)	grepArgs+=("$1"); shift;;
	--invert-grep)	grepModificationArgs+=("$1"); shift;;

	--one-more|--one-more-output|--one-more-only-to-terminal|--one-more-with-padding)
			revRangeArgs+=("$1"); shift;;
	--no-range)	revRangeArgs+=("$1"); shift; isWithRange=;;
	--one-more-command|--with-range)
			revRangeArgs+=("$1" "${2:?}"); shift; shift;;

	--with-log-args)
			shift; withLogArgs=all;;
	--with-log-args-except-last)
			shift; withLogArgs=except-last;;
	--)		break;;
	*)		allargs+=("$1"); shift;;
    esac
done
set -- "${allargs[@]}" "$@"

typeset -a logArgs=()
captureLogArgs()
{
    local arg; for arg
    do
	[ "$arg" = RANGE ] || logArgs+=("$arg")
    done
}
typeset -a finalGrepArg=()
parseOffFinalGrepArg()
{
    [ ${#grepArgs[@]} -eq 0 -a ${#finalGrepArg[@]} -eq 0 ] || return 1

    # No --grep given; the last argument is the text or /regexp/.
    if [ $# -eq 0 ]; then
	printUsage "$0"
	exit 2
    fi

    finalGrepArg=("${!#}")
    return 0
}
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)		    shift; printLongUsage "$0"; exit 0;;
	--keep-position)	    if parseOffFinalGrepArg "$@"; then
					[ $# -eq 0 ] || set -- "${@:1:$(($#-1))}"
				    fi
				    revRangeArgs+=("$@"); shift; shift	# --keep-position GIT-COMMAND
				    captureLogArgs "$@"
				    set --
				    break
				    ;;
	-[0-9])			    captureLogArgs "${@:3:$((${1#-} - 1))}"  # without -N and GIT-COMMAND
				    revRangeArgs+=("$1" "${@:2:${1#-}}")
				    shift ${1#-}    # GIT-COMMAND ARG1 ...
				    shift   # -N
				    if parseOffFinalGrepArg "$@"; then
					[ $# -eq 0 ] || set -- "${@:1:$(($#-1))}"
				    fi
				    break
				    ;;
	+[0-9])			    revRangeArgs+=("$1" "${@:2:$((${1#+} + 1))}")   # include GIT-COMMAND here
				    captureLogArgs "${@:2:${1#+}}"  # without +N and GIT-COMMAND
				    shift ${1#+}    # ARG1 ARG2 ARG3 ...
				    shift   # +N
				    shift # GIT-COMMAND
				    if parseOffFinalGrepArg "$@"; then
					[ $# -eq 0 ] || set -- "${@:1:$(($#-1))}"
				    fi
				    logArgs=("$@" "${logArgs[@]}")
				    set --
				    break
				    ;;
	*)			    break;;
    esac
done
if parseOffFinalGrepArg "$@"; then  # For plain GIT-COMMAND ... (where the range is appended).
    if [ $# -eq 1 ]; then
	# Have accidentally parsed the sole remaining GIT-COMMAND argument as the final
	# grep argument. Not good.
	printUsage "$0"
	exit 2
    fi
    set -- "${@:1:$(($#-1))}"
fi

typeset sharedLogArgs=()
case "$withLogArgs" in
    all)	    sharedLogArgs=("${logArgs[@]}" "$@");;
    except-last)    sharedLogArgs=("${logArgs[@]}" "$@"); sharedLogArgs=("${sharedLogArgs[@]:0:$((${#sharedLogArgs[@]}-1))}");;
esac

if [ -z "$revision" ]; then
    revision="$(git ${GIT_LOGRANGE_RANGE_COMMAND:?} --max-count 1 --pretty=tformat:%H "${grepModificationArgs[@]}" "${grepArgs[@]}" "${sharedLogArgs[@]}" "${finalGrepArg[@]}")"
    if [ -z "$revision" ]; then
	echo >&2 'Could not find a matching commit.'
	exit 1
    fi
fi

startRevision=
< <(diff --unchanged-line-format= --old-line-format='%dn %L' --new-line-format= -- \
    <(git log --first-parent --pretty=tformat:%H "$revision" "${sharedLogArgs[@]}") \
    <(git ${GIT_LOGRANGE_RANGE_COMMAND:?} --first-parent --pretty=tformat:%H "${grepModificationArgs[@]}" "${grepArgs[@]}" "$revision" "${sharedLogArgs[@]}" "${finalGrepArg[@]}") # Fortunately, "git log <revision> --follow -- <path>" also works; else, we would have to split sharedLogArgs into options and path arguments.
) IFS=' ' read -r firstDifferentCount firstDifferentRevision

if [ -n "$firstDifferentRevision" ]; then
    if [ $firstDifferentCount -eq 1 ]; then
	printf >&2 'The %s revision already does not match.\n' "$revision"
	exit 1
    else
	startRevision="$firstDifferentRevision"
    fi
fi

[ "$isWithRange" ] || revision=''   # Prevent "ERROR: --end-revision cannot be combined with --no-range!"; we don't need the end revision, as --no-range drops that, anyway.

exec git-rev-range --revision "$startRevision" ${revision:+--end-revision "$revision"} "${revRangeArgs[@]}" "$@"
