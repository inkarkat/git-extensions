#!/bin/bash

: ${GIT_CLONEBR_SEPARATOR=-}

printUsage()
{
    git-rev-range --help 2>&1 | sed \
	-e "1s#^.*\$#Print / execute GIT-COMMAND with the revision range to to its previous clone (FOO${GIT_CLONEBR_SEPARATOR}1 to FOO, FOO${GIT_CLONEBR_SEPARATOR}2 to FOO${GIT_CLONEBR_SEPARATOR}1, etc.)#" \
	-e '2,/^- /{ /^- /p; d; }' \
	-e '/^Usage:$/N' -e '/\(^\|\n\)Usage: */{ s/\(^\|\n\)\(Usage: *\)\?\([^ ]\+ \)*git-rev-range /\1\2'"$(basename "$1")"' /; s/ -r|--revision REVISION \[-e|--end-revision END-REVISION|/ [-n|--previous-clone-number N] [-b|--branch BRANCH] [/; s/ GIT-COMMAND \[\.\.\.\]/& [-b|--branch BRANCH]/; }'
}

# -b|--branch can also be passed after GIT-COMMAND; need to parse that
# separately.
startRev=
typeset -a args=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--branch|-b)	shift; startRev="$1"; shift;;
	--)		args+=("$1"); shift; break;;
	*)		args+=("$1"); shift;;
    esac
done
set -- "${args[@]}" "$@"

let previousCloneNumber=1
typeset -a revRangeArgs=()
isWithRange=t
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)			shift; printUsage "$0"; exit 0;;
	--previous-clone-number|-n)	shift; previousCloneNumber="$1"; shift;;
	--start-rev)			shift; startRev="$1"; shift;;
	--no-range)			revRangeArgs+=("$1"); shift; isWithRange=;;
	--keep-position|[+-][0-9])	revRangeArgs+=("$1"); shift; break;;
	*)				revRangeArgs+=("$1"); shift;;
    esac
done

currentBranchName="$(git-brname --real-branch-only)" || exit $?

if [[ ! "$currentBranchName" =~ ^(.+)"${GIT_CLONEBR_SEPARATOR}"([[:digit:]]+)$ ]]; then
    printf >&2 'ERROR: Current branch is not a cloned branch; the %s1 suffix is missing: %s\n' "$GIT_CLONEBR_SEPARATOR" "$currentBranchName"
    exit 1
fi
branchBase="${BASH_REMATCH[1]}"
previousClonedBranch=
for ((num=BASH_REMATCH[2] - 1, encounteredCloneCnt=0; num >= 0 && encounteredCloneCnt < previousCloneNumber; --num))
do
    previousClonedBranch="${branchBase}${GIT_CLONEBR_SEPARATOR}${num}"
    if git-existsbr -- "$previousClonedBranch"; then
	let encounteredCloneCnt+=1
    elif [ $num -eq 0 ] && git-existsbr -- "$branchBase"; then	# Support the usual FOO in addition to the unlikely FOO-0 base branch name.
	previousClonedBranch="$branchBase"
	let encounteredCloneCnt+=1
    fi
done
if [ $encounteredCloneCnt -eq 0 ]; then
    printf >&2 'ERROR: No additional clones of %s available.\n' "$currentBranchName"
    exit 1
elif [ $encounteredCloneCnt -lt $previousCloneNumber ]; then
    encounteredCloneCntPlural=s; [ $encounteredCloneCnt -eq 1 ] && encounteredCloneCntPlural=
    printf >&2 'ERROR: Only %d clone%s of %s available.\n' $encounteredCloneCnt "$encounteredCloneCntPlural" "$currentBranchName"
    exit 1
fi

[ "$isWithRange" ] || startRev=''   # Prevent "ERROR: --end-revision cannot be combined with --no-range!"; we don't need the end revision, as --no-range drops that, anyway.

exec git-rev-range --revision "$previousClonedBranch" ${startRev:+--end-revision} $startRev "${revRangeArgs[@]}" "$@"
