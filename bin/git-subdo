#!/bin/bash
set -o pipefail
shopt -qs extglob

hasProgressNotification=; type -t progressNotification >/dev/null && hasProgressNotification=t
hasProgressNotificationToAddendum=; type -t progressNotificationToAddendum >/dev/null && hasProgressNotificationToAddendum=t

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s%s%s\n' "$(basename "$1")" '[-q|--quiet] [--no-pager] [--no-header]' "${hasProgressNotification:+ [--progress overlay|title|command|notify${hasProgressNotificationToAddendum:+|addendum}]}" '[--separate-errors] [--no-git-color] [--single-success] [--abort-on-failure|-X|--abort-on EXIT_STATUS] [--interrupt-on-failure|--interrupt-on EXIT_STATUS] [-y|--yes] [--continue|--abort]  [--predicate-command "COMMANDLINE" [...]] -c|--command "COMMANDLINE" [-c ...] | [--] SIMPLECOMMAND [...] [-?|-h|--help]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Execute "git SIMPLECOMMAND" and/or COMMANDLINE in each Git submodule.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    echo
    cat <<HELPTEXT
To continue with COMMAND execution in case an unclean exit made the command to
fall out of the iteration, the next iteration can be triggered by re-executing
with --continue.
COMMAND execution puts a header line (unless --no-header) that contains the
current Git submodule before the command output.

    --no-pager		Do not page the output (so contents will scroll out of
			view if there's too much output).
    --no-header		Do not output the header line before command output (and
			no separating empty line after it).${hasProgressNotification:+
    --progress overlay|title|command|notify${hasProgressNotificationToAddendum:+|addendum}
			Report the current WORKING-COPY name (and count +
			percentage) in one of the following ways:
			overlay:    in the form of overlaid text, written via
				    ANSI escape sequences in the first line of
				    the terminal
			title:	    in the terminal's window title via ANSI
				    escape sequences
			command:    by invoking
					PROGRESSNOTIFICATION_COMMANDLINE${PROGRESSNOTIFICATION_REPORT_MARKER:+
				    while replacing $PROGRESSNOTIFICATION_REPORT_MARKER with the report}
			notify:	    via notify-send to the system's notification
				    system}${hasProgressNotificationToAddendum:+
			addendum:   via the addendum of the terminal"'"s window
				    title}
    --separate-errors	Do not combine command output and command errors into
			one (paged) stream. Commands that just cause error
			output won't have a header then. Error output will
			remain on its separate file descriptor and will not be
			paged. Useful if you want to suppress errors or handle
			them separately.
    --no-git-color	Do not pass a --color=... to "git SIMPLECOMMAND". (For
			COMMANDLINE you have to insert "\${gitColorArg[@]}"
			yourself.)
    --abort-on-failure	Abort iteration when COMMAND fails.
    --abort-on|-X EXIT_STATUS
			Abort iteration when COMMAND exits with EXIT_STATUS.
    --interrupt-on-failure
			Halt iteration when COMMAND fails. The iteration can
			then be manually restarted with --continue or aborted
			with --abort.
    --interrupt-on EXIT_STATUS
			Halt iteration when COMMAND exits with EXIT_STATUS.
    --single-success	Exit status is 0 if at least command in one of the
			local branches succeeded.
    --predicate-command CMD
			Skip submodules where CMD (executed in the submodule
			root) fails. The string {} is replaced with the relative
			path to the submodule; all variables from "git submodule
			foreach" are available as well.
    --command|-c CMD	Execute the passed command line. When this is a simple
			Git command, it can also be passed as such:
			    $(basename "$1") [...] [--] SIMPLECOMMAND
			If omitted, will just return to the shell for each
			branch.
Note: For paging and headers, this command has to control Git's color output.
Pass --no-git-color if "git SIMPLECOMMAND" does not support the --color=...
arguments. (For COMMANDLINE you have to insert "\${gitColorArg[@]}" yourself.)
You can still pass --color=always if you pipe this command's output yet still
want coloring of headers.

EXIT STATUS
Returns the last non-successful exit status. With --single-success,
non-successful executions are ignored unless all of them fail. In other words,
exit status is 0 if at least one command succeeded.
HELPTEXT
}

typeset -a pager=("${PAGER:-less}" --RAW-CONTROL-CHARS); [ -t 1 ] || pager=()
abortStatus=
abortComparison=-eq
interruptStatus=
interruptComparison=-eq
progressSink=
isSingleSuccess=
isQuiet=
isHeader=; type -t withHeader >/dev/null && isHeader=t
errorRedir='2>&1'
isGitColor=t
typeset -a colorArg=()
typeset -a args=("$@")
isNeedEval=
typeset -a predicateCommands=()
typeset -a commands=()
isYes=
iterationAction=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	    shift; printLongUsage "$0"; exit 0;;
	--abort-on-failure) shift; abortComparison=-ne; abortStatus=0;;
	--abort-on|-X)	    shift; abortStatus="$1"; shift;;
	--interrupt-on)	    shift; interruptStatus="$1"; shift;;
	--interrupt-on-failure)
			    shift; interruptComparison=-ne; interruptStatus=0;;
	--single-success)   shift; isSingleSuccess=t;;
	--quiet|-q)	    shift; isQuiet=t;;
	--no-pager)	    shift; pager=();;
	--no-header)	    shift; isHeader=;;
	--progress)	    shift; progressSink="$1"; shift;;
	--separate-errors)  shift; errorRedir='';;
	--no-git-color)	    shift; isGitColor=;;
	--no-color|--color=*)	colorArg=("$1"); shift;;
	--color)		colorArg=("$1" "$2"); shift; shift;;
	--yes|-y)	    shift; isYes=t;;
	--continue|--abort)
			    iterationAction="${1#--}"; shift;;
	--collect)	    iterationAction="${1#--}"; shift
			    submoduleStore="${1:?}"; shift
			    predicateCommands=("$@")
			    set --
			    break
			    ;;
	--predicate-command)
			    shift; predicateCommands+=(${predicateCommands:+&&} "$1"); shift;;
	--command|-c)	    shift; commands+=(${commands:+;} "$1"); isNeedEval=t; shift;;
	--)		    shift; break;;
	-*)		    { echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		    break;;
    esac
done
# With piping into withHeader / pager, we need to explicitly enable color for
# Git, unless this command's output itself is redirected. Also don't do this if
# the user explicitly turned off color.
gitColorArg=()
if [ -n "$pager" -o -n "$isHeader" ] && isNeedColorArgumentWhenPiping "${colorArg[@]}"; then
    colorArg=(--color=always)	# Force for withHeader
    [ "$isGitColor" ] && gitColorArg=(--color=always)	# Force for Git
fi

typeset -a gitCommand=(git-wrapper)
if [ $# -gt 0 ]; then
    if [ ${#gitColorArg[@]} -gt 0 ]; then
	# Simply appending gitColorArg doesn't work; many Git commands have a
	# special <path> or <commit> part at the end. Place it just behind the
	# Git subcommand by iterating arguments in the same way as the various
	# git-*-command metaprograms, and moving anything that is in front from
	# $@ to gitCommand.
	case "$1" in
	    [^-]*-command)  gitCommand+=("$1"); shift
			    while [ $# -ne 0 ]
			    do
				case "$1" in
				    --)		break;;
				    -*)		gitCommand+=("$1"); shift;;
				    *)		gitCommand+=("$1"); shift; break;;
				esac
			    done
			    ;;
	    *)		    while [ $# -ne 0 ]
			    do
				case "$1" in
				    -c) gitCommand+=("$1" "$2"); shift; shift;;
				    *)	gitCommand+=("$1"); shift; break;;
				esac
			    done
	esac
	gitCommand+=("${gitColorArg[@]}")
    fi

    if [ "$isNeedEval" ]; then
	# Combine --command and SIMPLECOMMAND; need to quote SIMPLECOMMAND to
	# undo the effects of eval.
	printf -v quotedSimpleCommand '%q ' "$@"
	commands+=(${commands:+;} "${quotedSimpleCommand% }")
    else
	commands=("${gitCommand[@]}" "$@")
    fi
fi

gitDir="$(git rev-parse --absolute-git-dir 2>/dev/null)" || exit $?
[ -n "$submoduleStore" ] || submoduleStore="${gitDir}/submoduleData" || exit $?
commandLineStore="${gitDir}/submoduleCommandLine"

if [ ${#commands[@]} -gt 0 ]; then
    storeQuoting=%q; [ "$isNeedEval" ] && storeQuoting=%s   # Already quoted for eval, but a SIMPLECOMMAND needs quoting because after recalling it from $commandLineStore, it's in one single argument and needs eval() to execute.
    printf "$storeQuoting " "${commands[@]}" > "$commandLineStore" || exit $?
fi

getNextSubmodule()
{
    [ -f "$submoduleStore" ] || return
    head -n 1 "$submoduleStore"
    sed -i '1d' "$submoduleStore"
    [ -s "$submoduleStore" ] || rm "$submoduleStore"
}

abortIfDesired()
{
    local status="${1:?}"; shift
    [ -n "$abortStatus" ] || return
    if [ "$status" $abortComparison $abortStatus ];then
	[ "$isQuiet" ] || printf >&2 'Note: Aborting iteration because the command failed (with exit status %d).\n' "$status"
	cleanup
	exit $status
    fi
}

interruptIfDesired()
{
    local status="${1:?}"; shift
    [ -n "$interruptStatus" ] || return
    if [ "$status" $interruptComparison $interruptStatus ];then
	[ "$isQuiet" ] || printf >&2 'Note: Interrupting iteration because the command failed (with exit status %d). Please check and then continue with --continue.\n' "$status"
	exit $status
    fi
}

cleanup()
{
    [ ! -e "$commandLineStore" ] || rm -- "$commandLineStore"
}

case "$iterationAction" in
    collect)
	if [ ${#predicateCommands[@]} -gt 0 ]; then
	    eval "${predicateCommands[@]//\{\}/$displaypath}" || exit 0
	fi
	{
	    printf '%s=%q; ' dirspec "$PWD" name "$name" sm_path "$sm_path" displaypath "$displaypath" sha1 "$sha1" toplevel "$toplevel"
	    echo
	} >> "$submoduleStore" || exit $?
	printf '%s\n' "$displaypath"
	exit
	;;
    abort)	cleanup; exit;;
    continue)
	if [ ${#commands[@]} -eq 0 -a -e "$commandLineStore" ]; then
	    # Recall command-line from original / previous call, unless it is
	    # overridden by updated arguments provided to this invocation.
	    commands=$(<"$commandLineStore")
	    # The command-line is read as one (escaped) argument, and therefore
	    # needs eval to execute.
	    isNeedEval=t
	fi
	readarray -t submodules < "$submoduleStore"
	;;
    '')
	if [ ${#commands[@]} -eq 0 ]; then
	    echo >&2 'ERROR: No COMMAND(s) specified; need to pass -c|--command "COMMANDLINE", or SIMPLECOMMAND.'
	    exit 2
	fi

	> "$submoduleStore" || exit 3
	printf -v quotedScriptFilespec %q "${BASH_SOURCE[0]}"
	printf -v quotedSubmoduleStore %q "${submoduleStore:?}"	# Need to pass this, as the Git dir that the store is based on will be different when in a submodule.
	printf -v quotedPredicateCommands ' %q' "${predicateCommands[*]}"
	readarray -t submodules < <(git submodule foreach --quiet --recursive "$quotedScriptFilespec --collect ${quotedSubmoduleStore}${quotedPredicateCommands}")
	if [ ${#submodules[@]} -eq 0 ]; then
	    echo >&2 'No submodules found!'
	    exit 1
	fi

	IFS=$'\n'
	if [ "$isYes" ]; then
	    [ "$isQuiet" ] || echo >&2 "Iterating over these submodule(s):
${submodules[*]}"
	else
	    echo >/dev/tty "Iterating over these submodule(s):
${submodules[*]}"
	    </dev/tty read -r -N 1 -p "Really iterate over these submodules? (y/n) " choice; echo >/dev/tty
	    [ "$choice" = "y" ] || exit 1
	fi
	;;
    *)	printf >&2 'Assert: Unhandled iterationAction %q\n' "$iterationAction"
	exit 3
	;;
esac

if [ "$hasProgressNotification" ] && [ -n "$progressSink" ]; then
    if [ "$progressSink" = addendum ]; then
	[ "$hasProgressNotificationToAddendum" ] && \
	    exec 3> >(progressNotificationToAddendum --prepend-count 'local branch' --count-to "${#submodules[@]}" 2>/dev/null)  # Silence "Cannot notify via titleupdate; TERMID not defined."
    else
	exec 3> >(progressNotification --to "$progressSink" --prepend-count 'local branch' --count-to "${#submodules[@]}" 2>/dev/null)
    fi

    reportProgress()
    {
	trap 'reportProgress() { :; }; trap PIPE' PIPE
	printf '%s\n' "$*" >&3 2>/dev/null  # Silence "printf: write error: Broken pipe"
    }
else
    reportProgress() { :; }
fi

subdo()
{
    : ${GIT_SUBDO_HEADER_ID:="subdo-$$-$RANDOM"}
    local isSuccess status=0
    while :
    do
	local status=0
	submoduleEnv="$(getNextSubmodule)"
	if [ -z "$submoduleEnv" ]; then
	    [ "$isQuiet" ] || echo >&2 'All submodules have been iterated over.'

	    cleanup; exit
	fi

	eval "$submoduleEnv" || exit 3
	cd "${dirspec:?}" || exit $?

	if [ "$isNeedEval" ]; then
	    typeset -a c=("${commands[@]}")
	else
	    typeset -a c=('"${commands[@]}"')
	fi
	reportProgress "${displaypath:?}"
	if (eval "${c[@]}" "${isHeader:+$errorRedir | withHeader "${colorArg[@]}" --id '$GIT_SUBDO_HEADER_ID' -- '${displaypath:?}'}"); then
	    isSuccess=t
	else
	    status=$?
	    abortIfDesired $status
	    interruptIfDesired $status
	fi
    done
    if [ "$isSingleSuccess" ]; then
	[ "$isSuccess" ]
    else
	return $status
    fi
}
eval "subdo ${pager:+$errorRedir |}" '"${pager[@]}"'
