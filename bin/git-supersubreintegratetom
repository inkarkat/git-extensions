#!/bin/bash

readonly scriptName="$(basename -- "${BASH_SOURCE[0]}")"

: ${GIT_SUPERSUBREINTEGRATETOM_RECENT_FETCH_AGE:=15m}

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-?|-h|--help]'
    printf 'Usage: GIT_REINTEGRATE_CHECK_COMMAND=CMD|GIT_CHECK_COMMAND=CMD %q %s\n' "$(basename "$1")" '[--same-branch|--for -|--for SUBMODULE [...] ;] [...]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '[...] --no-checks | -c|--command "CHECK-COMMANDLINE" [-c ...] | --exec SIMPLECOMMAND [...] ; [...]'
    printf 'Usage: echo CHECK-COMMANDLINES | %q %s\n' "$(basename "$1")" '[...] [--bare|[--initial-status NUM] [--trailing-prompt|--no-trailing-prompt] [--no-output-no-prompt] [--no-output-no-error] [--emulate-prompt]] [--no-success-no-count|--no-count-on N] [--exit-on-success|--exit-on-failure|--exit-on NUM] [--worst-status] [--comment COMMENT] [--summarize-failed ERROR-TEXT [--summarize-failed-separator SEP]] -'
    printf 'Usage: %q %s - <<EOF\n  CHECK-COMMANDLINE\n...\nEOF\n' "$(basename "$1")" '[...]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Merge / rebase the current branch of a superproject + submodule(s) to the master
branch via a reverse integration of the superproject; i.e. master is merged /
rebased to the current branch first so that the reintegration is a simple
fast-forward.
Performs additional sanity checks and chooses the right arguments based on
whether this is a short-lived feature with a single superproject commit or full
history exists.
The answers to some questions can be preconfigured via these boolean config
settings; when not configured (true or false), the user will be prompted every
time:
- reintegrate.superproject-in-hub   integrate superproject in and by GitHub
- reintegrate.submodule-in-hub	    integrate submodule(s) in and by GitHub
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    echo
    cat <<HELPTEXT
    --same-branch	Cover all submodules that are on the same branch as the
			superproject. By default, covers submodules that are
			modified in the superproject's current branch to master
			in my GitHub clone.
    --for SUBMODULE [...] ;
			Only consider the following SUBMODULE(s); i.e. all
			following arguments until an argument consisting of ';'
			is encountered.
    --for -		Only consider the SUBMODULE(s) read from stdin.
For all other arguments see ffintegrateto.
HELPTEXT
}

typeset -a affectedSubmodules=()
typeset -a affectedSubmoduleSourceCommand=(bomsubmodules)
typeset -a reintegrateArgs=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--same-branch)	shift; affectedSubmoduleSourceCommand=(subsamebrdo --subdo-command-name "${scriptName#git-}");;
	--for)		shift
			if [ "$1" = - ]; then
			    shift
			    while IFS=$'\n' read -r line
			    do
				affectedSubmodules+=("$line")
			    done
			else
			    while [ $# -gt 0 -a "$1" != ';' ]
			    do
				affectedSubmodules+=("$1")
				shift
			    done
			    if [ $# -eq 0 ]; then
				echo 'ERROR: --for must be concluded with ;!'; echo; printUsage "$0"
				exit 2
			    fi >&2
			    shift   # the ;
			fi
			if [ ${#affectedSubmodules[@]} -eq 0 ]; then
			    echo >&2 'ERROR: Expected at least one submodule, but none was passed.'
			    exit 2
			fi
			;;
	--)		reintegrateArgs+=("$1"); shift; break;;
	*)		reintegrateArgs+=("$1"); shift;;
    esac
done
set -- "${reintegrateArgs[@]}" "$@"

isInSubmodule=
typeset -a superprojectExecutor=()
goToSuperproject() { :; }
if git issubmodule; then
    isInSubmodule=t
    superprojectExecutor=(git superdo)
    goToSuperproject()
    {
	local superprojectRoot; superprojectRoot="$(git superproject)" || exit 3
	cd "$superprojectRoot" || exit 3
	header "../$(git-wcname)"

	isInSubmodule=
	superprojectExecutor=()
	submoduleExecutor=("${superprojectSubmoduleExecutor[@]}")
	goToSuperproject() { :; }
    }
elif ! git hassubmodules; then
    echo >&2 'ERROR: This is a standalone repository that neither has submodules nor is included in a superproject.'
    exit 2
else
    goToSuperproject()
    {
	header "$(git-wcname)"
    }
fi

[ -n "${affectedSubmodules+t}" ] \
    || readarray -t affectedSubmodules < <("${superprojectExecutor[@]:-git-wrapper}" ${superprojectExecutor:+--no-header --no-pager} "${affectedSubmoduleSourceCommand[@]}")
if [ ${#affectedSubmodules[@]} -eq 0 ]; then
    gitCommand='git'; [ -n "$HUB" ] && gitCommand='hub'
    echo 'ERROR: Expected at least one affected submodule in the commits on the branch, but none found.'
    printf 'Use %s superonlyreintegratetom instead if you just want to reintegrate the superproject.\n' "$gitCommand"
    exit 3
fi >&2
typeset -a superprojectSubmoduleExecutor=(git-subdo-core --subdo-command-name "${scriptName#git-}" --for "${affectedSubmodules[@]}" \;)
typeset -a submoduleExecutor=(); [ "$isInSubmodule" ] || submoduleExecutor=("${superprojectSubmoduleExecutor[@]}")

masterBranch="$(git-mbr)" || exit 3
typeset -a unintegratedSubmodules=()
checkForUnintegratedSubmodules()
{
    printf 'Checking for unintegrated submodules... '

    readarray -t unintegratedSubmodules < <(
	"${superprojectExecutor[@]:-git-wrapper}" ${superprojectExecutor:+--no-header --no-pager} \
	    subdo --subdo-command-name "${scriptName#git-}" --no-header --no-pager --for "${affectedSubmodules[@]}" \; \
		--predicate-command "branch=\$(git brname --real-branch-only 2>/dev/null) && [ \"\$branch\" != $masterBranch ]"
    )

    [ ${#unintegratedSubmodules[@]} -eq 0 ] || echo 'DONE.' # "If there are none, "No such submodules found." has already been printed.
}
checkForUnintegratedSubmodules
if [ ${#unintegratedSubmodules[@]} -eq 0 ]; then
    if [ ${#affectedSubmodules[@]} -eq 1 ]; then
	echo 'The single submodule has been reintegrated already; now integrating the superproject.'
    else
	printf 'All %d submodules have been reintegrated already; now integrating the superproject.\n' ${#affectedSubmodules[@]}
    fi

    readarray -t dirtySubmoduleReferences < <(
	"${superprojectExecutor[@]:-git-wrapper}" ${superprojectExecutor:+--no-header --no-pager} \
	    dirty --ignore-submodules=dirty -- "${affectedSubmodules[@]}"
    )
    if [ ${#dirtySubmoduleReferences[@]} -gt 0 ]; then
	if [ ${#dirtySubmoduleReferences[@]} -eq 1 ]; then
	    dirtySubmoduleReferencesPlural=
	    dirtySubmoduleReferencesAuxiliaryVerb=has
	else
	    dirtySubmoduleReferencesPlural=s
	    dirtySubmoduleReferencesAuxiliaryVerb=have
	fi
	dirtySubmoduleReferencesPlural=s; [ ${#dirtySubmoduleReferences[@]} -eq 1 ] && dirtySubmoduleReferencesPlural=

	userBinaryChoice --keep-prompt \
	    --introduction "Apparently the submodule reintegration was interrupted and ${#dirtySubmoduleReferences[@]} submodule reference$dirtySubmoduleReferencesPlural $dirtySubmoduleReferencesAuxiliaryVerb not been committed yet." \
	    --question "Update the changed submodule reference$dirtySubmoduleReferencesPlural in the superproject now?" \
	    --yes-no || exit 4

	action=completeSubmoduleReintegrationInSuperproject
    else
	if [ "$HUB" ] && hub-prcomments; then
	    userBinaryChoice --keep-prompt --console --question 'Really reintegrate the superproject despite the open PR review comments?' --yes-no || exit 4
	fi

	if [ "$HUB" ] && acceptStatus 0 99 hub-prapproval; then
	    userBinaryChoice --keep-prompt --console --question 'Really reintegrate the superproject?' --yes-no || exit 4
	fi

	action=reintegrateSuperproject
    fi
else
    affectedSubmodulesPlural=s
    if [ ${#affectedSubmodules[@]} -eq 1 ]; then
	affectedSubmodulesPlural=
	if [ "$isInSubmodule" ]; then
	    echo 'Integrating this single submodule.'
	else
	    echo 'Integrating the single submodule.'
	fi
    elif [ ${#unintegratedSubmodules[@]} -eq 1 ]; then
	printf 'Integrating the last submodule (of %d).\n' ${#affectedSubmodules[@]}
    else
	if [ "$isInSubmodule" ]; then
	    printf 'Integrating submodule %d of %d.\n' $((${#affectedSubmodules[@]} - ${#unintegratedSubmodules[@]} + 1)) ${#affectedSubmodules[@]}
	elif [ ${#affectedSubmodules[@]} -eq ${#unintegratedSubmodules[@]} ]; then
	    printf 'Integrating all %d submodules.\n' ${#affectedSubmodules[@]}
	else
	    printf 'Integrating the remaining %d of %d submodules.\n' ${#unintegratedSubmodules[@]} ${#affectedSubmodules[@]}
	fi
    fi
    action=reintegrateSubmodule

    if [ "$HUB" ] && "${submoduleExecutor[@]:-git-wrapper}" ${submoduleExecutor:+--single-success --include-superproject} prcomments; then
	[ "$isInSubmodule" ] \
	    && question='Really integrate this submodule' \
	    || question="Really integrate ${#affectedSubmodules[@]} submodule${affectedSubmodulesPlural}"
	question+=' despite the open PR review comments?'
	userBinaryChoice --keep-prompt --console --question "$question" --yes-no || exit 4
    fi

    if [ "$HUB" ] && acceptStatus 0 99 "${submoduleExecutor[@]:-git-wrapper}" ${submoduleExecutor:+--single-success --include-superproject} prapproval; then
	[ "$isInSubmodule" ] \
	    && question='Really integrate this submodule?' \
	    || question="Really integrate ${#affectedSubmodules[@]} submodule${affectedSubmodulesPlural}?"
	userBinaryChoice --keep-prompt --console --question "$question" --yes-no || exit 4
    fi
fi

isDidFetch=
fetchFirst()
{
    if [ ! "$isDidFetch" ] && "${superprojectExecutor[@]:-git-wrapper}" ${superprojectExecutor:+--no-header --no-pager} ofetchdate -gt "$GIT_SUPERSUBREINTEGRATETOM_RECENT_FETCH_AGE" --message $'\nLast fetched'; then
	echo 'Fetching origin first...'
	"${superprojectExecutor[@]:-git-wrapper}" ${superprojectExecutor:+--no-header --no-pager} ofetchonly-hushed --recurse-submodules=yes
	isDidFetch=t
	echo
    fi
}

reintegrateSubmodule()
{
    if [ "$HUB" ]; then
	if choice="$(git config --type bool --get reintegrate.submodule-in-hub)"; then
	    case "$choice" in
		true)   "${submoduleExecutor[@]:-git-wrapper}" ${submoduleExecutor:+--interactive} integrate --make-ready "$@" && return;;
		false)  ;;
		*)	printf >&2 'ASSERT: Invalid choice: %s\n' "$choice"; exit 3;;
	    esac
	else
	    "${submoduleExecutor[@]:-git-wrapper}" ${submoduleExecutor:+--interactive} integrate --offer "$@" && return
	fi
    fi

    fetchFirst

    "${superprojectExecutor[@]:-git-wrapper}" ${superprojectExecutor:+--no-header --no-pager} bomsubmodules \
	| negateThis "${superprojectExecutor[@]:-git-wrapper}" ${superprojectExecutor:+--no-header --no-pager} osuperhaspendingsubintegrations - || exit $?

    local superMessage="$("${superprojectExecutor[@]:-git-wrapper}" ${superprojectExecutor:+--no-header --no-pager} bomlo)"

    "${submoduleExecutor[@]:-git-wrapper}" ${submoduleExecutor:+--interactive} reintegratetom --no-push --no-delete --no-checks ${superMessage:+--merge-message-template "$superMessage"} || exit $?

    # Remaining steps (i.e. committing the submodule changes) happen in the superproject.
    completeSubmoduleReintegrationInSuperproject "$@"
}

completeSubmoduleReintegrationInSuperproject()
{
    goToSuperproject

    case $(git bomcount) in
	0)  echo >&2 'ERROR: Expected at least one commit in the superproject on the branch, but none found.'
	    exit 3
	    ;;
	1)  if git-dirty --ignore-submodules=dirty -- "${affectedSubmodules[@]}"; then
		echo 'Amending reintegrated submodule(s) to the single superproject commit.'
		git add -- "${affectedSubmodules[@]}" \
		    && git amen \
		    || exit $?
	    else
		echo 'The reintegrated submodule(s) have been fast-forwarded; nothing to amend.'
	    fi
	    ;;
	*)  local submoduleCnt=$((${#affectedSubmodules[@]} - ${#unintegratedSubmodules[@]} + 1))
	    if git-dirty --ignore-submodules=dirty -- "${affectedSubmodules[@]}"; then
		if [ $submoduleCnt -eq 1 ]; then
		    local affectedSubmodulesPlural=s; [ ${#affectedSubmodules[@]} -eq 1 ] && affectedSubmodulesPlural=
		    local commitMessage; printf -v commitMessage 'Housekeeping: Reintegrate submodule%s %s' "$affectedSubmodulesPlural" "$(joinBy ', ' "${affectedSubmodules[@]}")"
		    git add -- "${affectedSubmodules[@]}" \
			&& git-wrapper commit --edit --message "$commitMessage" \
			|| exit $?
		else
		    printf 'Amending the %d. reintegrated submodule to the previous superproject commit.\n' "$submoduleCnt"
		    git add -- "${affectedSubmodules[@]}" \
			&& git amen \
			|| exit $?
		fi
	    else
		printf 'This (%d.) reintegrated submodule has been fast-forwarded; nothing to amend.' "$submoduleCnt"
	    fi
	    ;;
    esac

    echo
    checkForUnintegratedSubmodules
    if [ ${#unintegratedSubmodules[@]} -gt 0 ]; then
	unintegratedSubmodulesPlural=s; [ ${#unintegratedSubmodules[@]} -eq 1 ] && unintegratedSubmodulesPlural=
	printf '%s more submodule%s to reintegrate: %s\n' ${#unintegratedSubmodules[@]} "$unintegratedSubmodulesPlural" "$(joinBy ', ' "${unintegratedSubmodules[@]}")"
	exit 0
    elif userBinaryChoice --keep-prompt --question 'Reintegrate the superproject now?' --yes-no; then
	reintegrateSuperproject "$@"
    else
	local gitCommand='git'; [ -n "$HUB" ] && gitCommand='hub'
	printf 'Continue with the reintegration of the superproject via $ %s %q' "$gitCommand" "${scriptName#git-}"
	[ $# -eq 0 ] || printf ' %q' "$@"
	printf '\n'
    fi
}

reintegrateSuperproject()
{
    goToSuperproject

    typeset -a integrateArgs=() ffintegratetoArgs=()
    case $(git bomcount) in
	0)  echo >&2 'ERROR: Expected at least one commit in the superproject on the branch, but none found.'
	    exit 3
	    ;;
	1)  echo "Rebasing the single superproject commit on top of ${masterBranch}."
	    integrateArgs=(--rebase-single)
	    ;;
	*)  # Disallow fast-forward to have a merge commit that maintains the history of
	    # how the feature grew.
	    echo "Maintaing the history of how the feature grew via a merge to ${masterBranch}."
	    ffintegratetoArgs=(--no-ff)
	    ;;
    esac

    if [ "$HUB" ]; then
	if ! "${submoduleExecutor[@]:-git-wrapper}" ${submoduleExecutor:+--no-pager --separate-errors} outlg \
	    | outputAndPrintf 'Note: Submodule(s) have outgoing reintegration commits; integration in and by GitHub not possible:\n'
	then
	    if choice="$(git config --type bool --get reintegrate.superproject-in-hub)"; then
		case "$choice" in
		    true)   hub-integrate --make-ready "${integrateArgs[@]}" "$@" && return;;
		    false)  ;;
		    *)	    printf >&2 'ASSERT: Invalid choice: %s\n' "$choice"; exit 3;;
		esac
	    else
		hub-integrate --offer "${integrateArgs[@]}" "$@" && return
	    fi
	fi
    fi

    git-dirty --print-error --error-message 'ERROR: The superproject working copy is still dirty.' \
	&& exit 1

    fetchFirst

    if hub-workflow-status --has-workflow; then
	if [ "$HUB" ]; then
	    export GIT_REINTEGRATE_PRE_PUSH_COMMAND="printf '\nWaiting for the GitHub action to validate the build on the branch before pushing.\n'; hub-workflow-status --revision HEAD --latest --is completed --wait 'The fast-forward-integrated branch build'"
	else
	    export GIT_REINTEGRATE_PRE_PUSH_COMMAND="printf '\nNote: Wait for the GitHub action to validate the build on the branch before pushing.\n'"
	fi
    fi

    exec git-ffintegrateto --branch "$masterBranch" --push-branch "${integrateArgs[@]}" "${ffintegratetoArgs[@]}" --push-submodules --delete-merged-submodule-branches "$@"
}

$action "$@"
