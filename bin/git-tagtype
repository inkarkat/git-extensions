#!/bin/bash
set -o pipefail

printUsage()
{
    cat <<HELPTEXT
List only those tags of the passed (annotated or lightweight) type.
HELPTEXT
    printf 'Usage: %q %s\n' "$(basename "$1")" 'all|annotated|lightweight [-v|--verbose [-v]] [[-l|--list] <pattern>] [-?|-h|--help]'
}

tagType=
case "$1" in
    --help|-h|-\?)	shift; printUsage "$0"; exit 0;;
    --no-color|--color=*)
			shift;;
    --color)		shift; shift;;
    all)		;;
    annotated)		tagType=tag;;
    lightweight)	tagType=commit;;
    *)			printf >&2 'ERROR: Invalid tag type %s; must be either annotated or lightweight.\n' "$1"; exit 2;;
esac; shift

verboseFormat=
pattern=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--no-color|--color=*)
			shift;;
	--color)	shift; shift;;
	--verbose|-v)	shift
			if [ -z "$verboseFormat" ]; then
			    verboseFormat='%(contents:subject)'
			else
			    verboseFormat='%(contents:lines=99)' # XXX: %(contents) always adds a newline at the end, but mostly tags just have a subject and no body, so this would add a lot of empty lines for nothing. Cp. https://stackoverflow.com/a/26366791/813602
			fi
			;;
	--list|-l)	shift; pattern="$1"; shift;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
case $# in
    0)	;;
    1)	pattern="$1"; shift;;
    *)	printUsage "$0" >&2; exit 2;;
esac

patternMatcher()
{
    while IFS=$'\t' read -r tagName remainder
    do
	case "$tagName" in
	    $pattern) printf '%s%s\n' "$tagName" "${remainder:+$'\t'}${remainder}";;
	esac
    done
}

tagList()
{
    local verboseType; [ -n "$tagType" ] || verboseType='%(objecttype)'
    git for-each-ref --format "${tagType:+%(objecttype)$'\t'}%(refname:strip=2)${verboseFormat:+${verboseType:+$'\t'$verboseType}$'\t'%(committername)%(taggername)$'\t'}${verboseFormat}" --sort=version:refname refs/tags
    # Note: There is %(creator) that resolves to either %(committer) or
    # %(tagger) depending on the tag type, but that one unfortunately does not
    # support the appendices ("name"). But as only one of them is set, a simple
    # concatenation will do for us.
}

tagTypeFilter()
{
    awk --field-separator $'\t' -v tagType="$tagType" 'BEGIN { OFS="\t"; } $1 == tagType { $1 = ""; sub(OFS, ""); print; }'
}

typeset -a pager=("${PAGER:-less}" --RAW-CONTROL-CHARS)
typeset -a formatter=(column -s $'\t' -t -n --keep-empty-lines)
if [ ! -t 1 ]; then
    pager=()
    formatter=()
fi
[ -n "$verboseFormat" ] || formatter=()	# We only need formatting with verbose output.

eval tagList \
    "${tagType:+| tagTypeFilter}" \
    "${pattern:+| patternMatcher}" \
    "${formatter:+|}" '"${formatter[@]}"' \
    "${pager:+|}" '"${pager[@]}"'
