#!/bin/bash

: ${GIT_VERBOSELOCALCONFIG_NOOP_EXIT:=99}

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-d|--description DESCRIPTION] [--include-location] [--accept-nonlocal|--localize] set|unset [CONFIG-OPTIONS ...] NAME VALUE [-?|-h|--help]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Set per-repo Git configuration and print a message if it actually changed.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    echo
    cat <<HELPTEXT
    --description|-d DESCRIPTION
			Print DESCRIPTION instead of synthesizing a message from
			the passed arguments.
    --include-location	Append the working copy's directory to the message to
			identify the repository.
    --accept-nonlocal	Don't set the local configuration if the current
			configuration (from another scope) already has that VALUE.
			By default, the VALUE would be configured and therefore
			the repo would become independent from changes in any
			outer configuration scope.
    --localize		Check for existence of VALUE in all configuration scopes
			and set the local configuration even if VALUE is already
			configured elsewhere (making the repo independent from
			changes in any outer configuration scope). By default,
			other configuration is completely ignored; the effect is
			the same. This flag only changes the wording of the
			generated message.
EXIT STATUS:
    0	Complete success.
    $GIT_VERBOSELOCALCONFIG_NOOP_EXIT	Config already exists / already unset, no action necessary.
    *   any exit status from git config
HELPTEXT
}

configAction=
description=
location=
isAppend=
isReplace=
unset matchValue
existenceCheck=scalarCheck
nonLocalAction=
typeset -a args=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--description|-d)
			shift; description="${1:?}"; shift;;
	--include-location)
			shift; location="$PWD";;
	--accept-nonlocal)
			shift; nonLocalAction=acceptNonLocal;;
	--localize)	shift; nonLocalAction=localize;;

	set)		[ -n "$configAction" ] || configAction="${1}Config"; shift
			if [ $# -lt 2 ]; then
			    printUsage "$0" >&2
			    exit 2
			fi
			value="${!#}"; set -- "${@:1:$(($#-1))}"
			;;
	unset)		[ -n "$configAction" ] || configAction="${1}Config"; shift;;
	--append)	shift; isAppend=t; existenceCheck=dictCheck;;
	--value)	args+=("$1" "${2?}"); matchValue="$2"; shift; shift; existenceCheck=dictCheck;;
	--value=*)	args+=("$1"); matchValue="${1#--value=}"; shift; existenceCheck=dictCheck;;
	--)		args+=("$1"); shift; break;;
	*)		args+=("$1"); shift;;
    esac
done
set -- "${args[@]}" "$@"
if [ $# -lt 1 ]; then
    printUsage "$0" >&2
    exit 2
fi
name="${!#}"
set -- "${@:1:$(($#-1))}"

gitWrapper()
{
    local gitPrefix
    case ",${DEBUG:-}," in
	*,git,*) gitPrefix=verbose;;
	*,git\!,*) gitPrefix=echotrace;;
    esac
    $gitPrefix git "$@"
}

makeDescription()
{
    local actionVerb multiActionPreposition=
    case "$configAction" in
	setConfig)
	    case "$value" in
		true)	actionVerb='Enabling'; unset value;;
		false)	actionVerb='Disabling'; unset value;;
		'')	actionVerb='Clearing'; unset value;;
		*)	if [ "$isReplace" ]; then
			    actionVerb="Replacing $matchValue with"
			    multiActionPreposition='in'
			elif [ "$isAppend" ] || [ -n "${matchValue+t}" ]; then
			    actionVerb='Adding'
			    multiActionPreposition='to'
			else
			    actionVerb='Setting'
			fi
			;;
	    esac
	    ;;
	unsetConfig)
		actionVerb='Removing'
		[ "$isReplace" ] && value="$matchValue" || value='all configured values'
		multiActionPreposition='from'
		;;
	*)	printf >&2 'ASSERT: Unhandled configAction: %s\n' "$configAction"; exit 3;;
    esac

    local renderedValue=''; [ -z "${value+t}" ] || renderedValue="${value:-empty}"
    [ -n "$multiActionPreposition" ] \
	&& printf '%s %s %s %s' "${actionVerbPrefix:-$actionVerb}${actionVerbPrefix:+ ${actionVerb,}}" "$renderedValue" "$multiActionPreposition" "$name" \
	|| printf '%s %s%s' "${actionVerbPrefix:-$actionVerb}${actionVerbPrefix:+ ${actionVerb,}}" "$name" "${renderedValue:+ to }$renderedValue"
}

scalarCheck()
{
    [ "$(git config get "$@" "$name")" = "$value" ]
}

dictCheck()
{
    # --value may be a pattern or fixed value; cannot use simple set containment,
    # and instead query the config directly.
    if [ -n "${matchValue+t}" ]; then
	if git config get --all "$@" "$name" >/dev/null; then
	    isReplace=t
	    return 1
	else
	    return 0
	fi
    fi

    typeset -A configuredValues=()
    local line; while IFS=$'\n' read -r line
    do
	configuredValues["$line"]=t
    done < <(git config get --all "$@" "$name")
    [ "${configuredValues["$value"]}" ]
}

acceptNonLocal()
{
    exit $GIT_VERBOSELOCALCONFIG_NOOP_EXIT
}

actionVerbPrefix=
localize()
{
    actionVerbPrefix='Localizing'
}

setConfig()
{
    gitWrapper config set --local ${isAppend:+--append} "$@" "$name" "$value"
}

unsetConfig()
{
    gitWrapper config unset --local "$@" "$name"
}


$existenceCheck --local "$@" && exit $GIT_VERBOSELOCALCONFIG_NOOP_EXIT
if [ -n "$nonLocalAction" ] && [ "$configAction" = setConfig ]; then
    $existenceCheck "$@" && $nonLocalAction
fi
$configAction "$@" \
    && printf '%s\n' "${description:-$(makeDescription "$@")}${location:+ for $location}"
