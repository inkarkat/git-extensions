#!/bin/bash

printUsage()
{
    cat <<HELPTEXT
Delete all passed branch(es) locally as well as in the tracked remote (unless it
has already been auto-deleted by GitHub).
HELPTEXT
    echo
    printf 'Usage: [HUB_DELETEMERGEDBRANCHES_TIMEOUT_BASEEPOCH=EPOCH] %q %s\n' "$(basename "$1")" '[-y|--yes] [--] <branch>|<revision> [...] [-?|-h|--help]'
}

typeset -a gitRemoteMutateArgs=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--no-color|--color=*)
			shift;;
	--color)	shift; shift;;
	--yes|-y)	gitRemoteMutateArgs+=("$1"); shift;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
if [ $# -eq 0 ]; then
    printUsage "$0" >&2
    exit 2
fi

hasBranchBeenAutoDeletedOnMerge()
{
    local trackedRemote="${1:?}"; shift
    local branch="${1:?}"; shift

    [ "$(hub-settings --remote "$trackedRemote" get deleteBranchOnMerge 2>/dev/null)" = 'true' ] || return 1
    local abortTimeout=20
    local adaptedAbortTimeout=$((abortTimeout - (SECONDS - baseEpoch)))
    abortTimeout=$((
	adaptedAbortTimeout > 0
	    ? (adaptedAbortTimeout > abortTimeout
		? abortTimeout
		: adaptedAbortTimeout
	    )
	    : 0
    ))

    local abortTimeout=$((${HUB_DELETEMERGEDBRANCHES_TIMEOUT_BASEEPOCH:-0} + ${HUB_DELETEMERGEDBRANCHES_TIMEOUT:-0}))
	[ $abortTimeout -gt 0 ] || return 1
    RETRY_SUCCEED_VERB='got auto-deleted' RETRY_FAIL_VERB='still exists' RETRY_ABORT_VERB='did not get auto-deleted' \
	retry --silent-command --command-name 'The remote branch' --verbose-or-none --interval 2 --abort-timeout $abortTimeout \
	    negateThis git-existsremotebr "$trackedRemote" "$branch"
}

readonly baseEpoch=${HUB_DELETEMERGEDBRANCHES_TIMEOUT_BASEEPOCH:-$(date +%s)}; SECONDS=$baseEpoch
status=99
for branch
do
    if ! git-existsbr "$branch"; then
	currentBranch="$(git-brname --real-branch-only)" # Ignore the current branch; I'd be unexpected (to say the least) to remove it, and unfortunately in a fast-forward integration this would be the first candidate.
	resolvedBranch="$(git name-rev --name-only --no-undefined --exclude 'refs/tags/*' --exclude 'refs/remotes/*' --exclude "refs/heads/${currentBranch}" -- "$branch")"
	if [ -n "$resolvedBranch" ]; then
	    branch="$resolvedBranch"
	else
	    printf >&2 'ERROR: No branch %s\n' "$branch"
	    status=1
	fi
    fi

    tracks="$(git-tracks "$branch" 2>/dev/null)"
    trackedRemote="${tracks%%/*}"
    typeset -a rldeletebrArgs=()
    if [ -z "$trackedRemote" ]; then
	trackedRemote='origin'
	rldeletebrArgs=(--ignore-missing-in-origin)
    fi
    if hasBranchBeenAutoDeletedOnMerge "$trackedRemote" "$branch"; then
	printf >&2 "Note: GitHub already has automatically deleted the merged branch '%s' in %s.\\n" "$branch" "$trackedRemote"
	if git-existsbr -- "$branch"; then
	    git-deletebr --force "${gitRemoteMutateArgs[@]}" -- "$branch"	# Need force here because without a pull the local repository is not aware of the remote branch deletion and would complain about it not being fully merged.
	    status=$(status99Reduction "$status" $?)
	else
	    printf >&2 "Note: The local branch '%s' already got deleted.\\n" "$branch"
	    status=$(status99Reduction "$status" 99)
	fi
    else
	git-rldeletebr "$trackedRemote" --force --ignore-missing-local "${rldeletebrArgs[@]}" "${gitRemoteMutateArgs[@]}" -- "$branch"	# Need force here for when the local merged branch got amended due to a conflict resolution during the merge.
	status=$(status99Reduction "$status" $?)
    fi
done
exit $status
